
# Домашнее задание к занятию «Микросервисы: принципы»

Вы работаете в крупной компании, которая строит систему на основе микросервисной архитектуры.
Вам как DevOps-специалисту необходимо выдвинуть предложение по организации инфраструктуры для разработки и эксплуатации.

## Задача 1: API Gateway 

Предложите решение для обеспечения реализации API Gateway. Составьте сравнительную таблицу возможностей различных программных решений. На основе таблицы сделайте выбор решения.

Решение должно соответствовать следующим требованиям:
- маршрутизация запросов к нужному сервису на основе конфигурации,
- возможность проверки аутентификационной информации в запросах,
- обеспечение терминации HTTPS.

Обоснуйте свой выбор.

## Задача 2: Брокер сообщений

Составьте таблицу возможностей различных брокеров сообщений. На основе таблицы сделайте обоснованный выбор решения.

Решение должно соответствовать следующим требованиям:
- поддержка кластеризации для обеспечения надёжности,
- хранение сообщений на диске в процессе доставки,
- высокая скорость работы,
- поддержка различных форматов сообщений,
- разделение прав доступа к различным потокам сообщений,
- простота эксплуатации.

Обоснуйте свой выбор.

# Решение 

## <a id="api-gateway">Задача 1: API Gateway</a>

### Требования
- Маршрутизация запросов к нужному сервису на основе конфигурации
- Возможность проверки аутентификационной информации в запросах
- Обеспечение терминации HTTPS

---

### Сравнительная таблица решений

| Решение | Маршрутизация по конфигурации | Проверка аутентификации | Терминация HTTPS | Примечания (кратко) |
| --- | --- | --- | --- | --- |
| **Kong Gateway** | ✅ Да (routes/services, declarative config) | ✅ Да (плагины JWT, key-auth, mTLS; возможно подключение OIDC) | ✅ Да | Много готовых политик, удобен для централизованного API Gateway |
| **NGINX** | ✅ Да (upstream/location) | ⚠️ Частично (часто через внешние компоненты; расширенные возможности — в коммерческих сборках) | ✅ Да | Очень быстрый и простой, но “API management” часто приходится собирать вручную |
| **Envoy** | ✅ Да (конфиг/xDS) | ✅ Да (через внешний auth/ext_authz) | ✅ Да | Очень мощный, но сложнее в эксплуатации и внедрении |
| **Spring Cloud Gateway** | ✅ Да (routes/filters) | ✅ Да (через Spring Security/OAuth2/JWT) | ✅ Да | Хорош в Java/Spring-стеке, но менее универсален для разнородных платформ |
| **Traefik** | ✅ Да (динамическая конфигурация) | ⚠️ Частично (через middleware/внешние провайдеры) | ✅ Да | Удобен в Kubernetes, но набор “коробочных” политик обычно скромнее |

---

### Выбор решения
**Выбранное решение: Kong Gateway**

#### Обоснование выбора
1. **Маршрутизация по конфигурации**  
   Kong поддерживает декларативный подход: маршруты/сервисы описываются конфигурацией, что удобно для GitOps/IaC.

2. **Проверка аутентификации**  
   Для типовых сценариев есть готовые плагины (JWT, API keys, mTLS), что ускоряет внедрение и снижает риск ошибок.

3. **Терминация HTTPS**  
   Kong работает как единая точка входа и выполняет TLS termination, упрощая безопасность и управление сертификатами.

4. **Эксплуатация и развитие**  
   Плагинная архитектура позволяет централизованно добавлять политики (rate limit, логирование, трассировка, заголовки, CORS) без изменений в микросервисах.

---

### Мини-схема (как это обычно выглядит)
- Клиент → **Kong (HTTPS)** → внутренние сервисы (HTTP или mTLS)
- Проверка токенов/ключей выполняется на уровне Gateway
- Единые политики безопасности и лимиты применяются до попадания запроса в микросервис

---

## <a id="broker">Задача 2: Брокер сообщений</a>

### Требования
- Поддержка кластеризации для обеспечения надёжности
- Хранение сообщений на диске в процессе доставки
- Высокая скорость работы
- Поддержка различных форматов сообщений
- Разделение прав доступа к различным потокам сообщений
- Простота эксплуатации

---

### Сравнительная таблица брокеров

| Брокер | Кластеризация/HA | Диск (persist) | Скорость | Форматы сообщений | Разграничение доступа | Простота эксплуатации | Примечания (кратко) |
| --- | --- | --- | --- | --- | --- | --- | --- |
| **RabbitMQ** | ✅ Да (кластер; quorum queues для HA) | ✅ Да | ✅ Высокая для typical messaging | ✅ Любые (payload), протокол AMQP + плагины (MQTT/STOMP) | ✅ Да (users/vhosts/permissions) | ✅ Обычно проще | Хороший баланс требований для микросервисов |
| **Apache Kafka** | ✅ Да (репликация) | ✅ Да (лог на диске) | ✅ Очень высокая | ✅ Любые (payload), формат на уровне приложения | ✅ Да (ACL на топики) | ⚠️ Сложнее | Отлично для event streaming и больших объёмов |
| **Apache Pulsar** | ✅ Да | ✅ Да | ✅ Высокая | ✅ Любые (payload) | ✅ Да (тенанты/неймспейсы) | ❌ Обычно сложнее | Мощно, но много компонентов |
| **NATS + JetStream** | ✅ Да | ✅ Да | ✅ Очень высокая (низкая задержка) | ✅ Любые (payload) | ✅ Есть модели авторизации | ✅/⚠️ Относительно просто | Отлично для low-latency, но модель отличается от “классических” очередей |
| **ActiveMQ Artemis** | ✅ Да | ✅ Да | ⚠️ Средняя/высокая | ✅ JMS/AMQP и др. | ✅ Да | ⚠️ Средняя | Часто в enterprise Java-сценариях |

---

### Выбор решения
**Выбранное решение: RabbitMQ**

#### Обоснование выбора
1. **Надёжность и кластеризация**  
   RabbitMQ поддерживает кластеризацию; для высокой надёжности применяются **quorum queues** (репликация и устойчивость).

2. **Хранение сообщений на диске**  
   Сообщения могут храниться на диске (persist), что соответствует требованию “не терять сообщения в процессе доставки”.

3. **Высокая скорость для задач микросервисов**  
   RabbitMQ хорошо подходит для типовых паттернов: очереди команд, маршрутизация, fanout/topic, delayed messages (через расширения).

4. **Поддержка разных форматов/протоколов**  
   Брокер не “навязывает” формат (JSON/Protobuf/Avro/текст/бинарь — всё возможно как payload).  
   Дополнительно — плагины для MQTT/STOMP при необходимости интеграций.

5. **Разделение прав доступа**  
   Через **vhost + permissions** удобно разделять окружения (dev/stage/prod) и домены (по командам/системам).

6. **Простота эксплуатации**  
   По сравнению с Kafka/Pulsar обычно быстрее вводится в эксплуатацию и проще администрируется для сценариев “сообщения между сервисами”.

---

## Чек-лист соответствия требованиям

### API Gateway
- [x] Маршрутизация по конфигурации
- [x] Проверка аутентификации
- [x] Терминация HTTPS

### Брокер сообщений
- [x] Кластеризация/надёжность
- [x] Хранение сообщений на диске
- [x] Высокая скорость работы (для typical messaging)
- [x] Поддержка различных форматов сообщений
- [x] Разделение прав доступа
- [x] Простота эксплуатации

---

## Итог
- **API Gateway:** выбран **Kong Gateway** — максимально закрывает требования “из коробки” и удобен для централизованных политик.
- **Брокер сообщений:** выбран **RabbitMQ** — сбалансирован по HA/persist/скорости/правах и проще в эксплуатации для микросервисного взаимодействия.
